1.1.0 (December 22, 2021)
 - Added support for client-side SDK instances to run in "consumer" and "partial consumer" modes, with a custom implementation of it's internal storage modules, enabling customers to implement this caching in any storage technology of choice and connect it to the SDK instance itself which will use it instead of in-memory storage.
 - Updated multiple modules due to general polishing and improvements.
 - Updated ioredis dependency for vulnerability fixes.
 - Bugfixing - Fixed issue returning dynamic configs if treatment name contains a dot (".").

1.0.0 (October 20, 2021)
 - BREAKING CHANGE on multiple modules due to general polishing, improvements and bug fixes. In most cases the change is to use named exports. This affected mostly modules related with synchronization and storages.
   - Updated streaming logic to use the newest version of our streaming service, including:
     - Integration with Auth service V2, connecting to the new channels and applying the received connection delay.
     - Implemented handling of the new MySegmentsV2 notification types (SegmentRemoval, KeyList, Bounded and Unbounded)
     - New control notification for environment scoped streaming reset.
 - Updated localhost mode to emit SDK_READY_FROM_CACHE event in Browser when using localStorage (Related to issue https://github.com/splitio/react-client/issues/34).
 - Updated dependencies for vulnerability fixes.

0.1.0 (March 30, 2021)
 - Initial public release. It includes common modules to be consumed by the different Split implementations written in JavaScript. Based on the original JS SDK in the `javascript-client` repository.
 - It's designed with a modular approach, with the following goals in mind:
   - Dependents should be able to include the modules that are needed for, as an example, a storage.
   - Dependents should be able to use the module that's specific for their runtime environment, allowing for better usage of native APIs as well as to build optimizations targeted by each platform.
   - Size reduction should be applicable when possible.
   - Design should be extensible, specially for modules that act as an orchestrator.
   - Code reusability.
